/*
 * SPDX-FileCopyrightText: 2024 Zextras <https://www.zextras.com>
 *
 * SPDX-License-Identifier: AGPL-3.0-only
 */
/* eslint-disable @typescript-eslint/ban-types,@typescript-eslint/no-explicit-any */
// THIS FILE IS AUTOGENERATED BY GRAPHQL-CODEGEN. DO NOT EDIT!
import type { GraphQLResolveInfo, GraphQLScalarType, GraphQLScalarTypeConfig } from 'graphql';

export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = {
	[_ in K]?: never;
};
export type Incremental<T> =
	| T
	| { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
export type RequireFields<T, K extends keyof T> = Omit<T, K> & { [P in K]-?: NonNullable<T[P]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
	ID: { input: string; output: string };
	String: { input: string; output: string };
	Boolean: { input: boolean; output: boolean };
	Int: { input: number; output: number };
	Float: { input: number; output: number };
	DateTime: { input: number; output: number };
};

export type Account = DistributionList | User;

/**
 *  Definition of a collaboration link. It represents an internal link that allows a logged user to
 *  auto-share a specific node with a specific permission.
 *  Each node can have at maximum 2 CollaborationLink:
 *   - one that allows to auto-share the node with the READ+SHARE permission;
 *   - one that allows to auto-share the node with the WRITE+SHARE permission.
 *  A collaboration link can be generated only if the requester has the <strong>can_share</strong>
 *  permission on the node.
 */
export type CollaborationLink = {
	__typename: 'CollaborationLink';
	/**  Link creation timestamp. */
	created_at: Scalars['DateTime']['output'];
	/**  Unique identifier of the CollaborationLink. */
	id: Scalars['ID']['output'];
	/**  Node on which the share is created when a logged user clicks on the collaboration link. */
	node: File | Folder;
	/**  The permission type created/updated when a logged user clicks on the collaboration link. */
	permission: SharePermission;
	/**
	 *  Full URL allowing a logged user to auto-share the related node with the related permission.
	 *  After the creation/update of the share, the system returns a redirect to the internal url of
	 *  the shared node.
	 */
	url: Scalars['String']['output'];
};

export type Config = {
	__typename: 'Config';
	name: Scalars['String']['output'];
	value: Scalars['String']['output'];
};

export type DistributionList = {
	__typename: 'DistributionList';
	id: Scalars['ID']['output'];
	name: Scalars['String']['output'];
	users: Array<Maybe<User>>;
};

export type DistributionListUsersArgs = {
	cursor?: InputMaybe<Scalars['String']['input']>;
	limit: Scalars['Int']['input'];
};

/**  Definition of the File type which implements the Node interface */
export type File = Node & {
	__typename: 'File';
	cloned_from_version: Maybe<Scalars['Int']['output']>;
	/**
	 *  Returns all the CollaborationLinks of current node.
	 *  It can be maximum of 2 collaboration links:
	 *   - one that allows to auto-share the node with the READ+SHARE permission;
	 *   - one that allows to auto-share the node with the WRITE+SHARE permission.
	 */
	collaboration_links: Array<Maybe<CollaborationLink>>;
	/**  File creation timestamp */
	created_at: Scalars['DateTime']['output'];
	/**  Creator of the file */
	creator: User;
	/**  Description of the file */
	description: Scalars['String']['output'];
	/**  Extension of the file */
	extension: Maybe<Scalars['String']['output']>;
	/**  True if the owner has marked the file as favourite, false otherwise */
	flagged: Scalars['Boolean']['output'];
	/**  Unique identifier of the file */
	id: Scalars['ID']['output'];
	/**  Boolean representing if a version in kept forever or not */
	keep_forever: Scalars['Boolean']['output'];
	/**  Last user who has edited the file */
	last_editor: Maybe<User>;
	links: Array<Maybe<Link>>;
	/**  Mime type of the file */
	mime_type: Scalars['String']['output'];
	/**  Name of the file */
	name: Scalars['String']['output'];
	/**  Owner of the file */
	owner: Maybe<User>;
	/**  Parent folder containing the file */
	parent: Maybe<File | Folder>;
	/**  File permissions of the user making the request */
	permissions: Permissions;
	/**  The top level root where the node resides */
	rootId: Maybe<Scalars['ID']['output']>;
	/**  Specific share of the current file with the target user (if exists) */
	share: Maybe<Share>;
	/**  List of shares of the current file (if they exist) */
	shares: Array<Maybe<Share>>;
	/**  Size of the file */
	size: Scalars['Float']['output'];
	/**  Type of the node */
	type: NodeType;
	/**  File update timestamp */
	updated_at: Scalars['DateTime']['output'];
	/**  Version of the file */
	version: Scalars['Int']['output'];
};

/**  Definition of the File type which implements the Node interface */
export type FileShareArgs = {
	share_target_id: Scalars['ID']['input'];
};

/**  Definition of the File type which implements the Node interface */
export type FileSharesArgs = {
	cursor?: InputMaybe<Scalars['String']['input']>;
	limit: Scalars['Int']['input'];
	sorts?: InputMaybe<Array<ShareSort>>;
};

/**  Definition of the Folder type which implements the Node interface */
export type Folder = Node & {
	__typename: 'Folder';
	/**  List of all child nodes of a folder. */
	children: NodePage;
	/**
	 *  Returns all the CollaborationLinks of current node.
	 *  It can be maximum of 2 collaboration links:
	 *   - one that allows to auto-share the node with the READ+SHARE permission;
	 *   - one that allows to auto-share the node with the WRITE+SHARE permission.
	 */
	collaboration_links: Array<Maybe<CollaborationLink>>;
	/**  Folder creation timestamp */
	created_at: Scalars['DateTime']['output'];
	/**  Creator of the folder */
	creator: User;
	/**  Description of the folder */
	description: Scalars['String']['output'];
	/**  True if the owner has marked the folder as favourite, false otherwise */
	flagged: Scalars['Boolean']['output'];
	/**  Unique identifier of the folder */
	id: Scalars['ID']['output'];
	/**  Last user who has edited the folder */
	last_editor: Maybe<User>;
	links: Array<Maybe<Link>>;
	/**  Name of the folder */
	name: Scalars['String']['output'];
	/**  Owner of the folder */
	owner: Maybe<User>;
	/**  Parent folder containing the folder. The parent can be null when the current folder is the root */
	parent: Maybe<File | Folder>;
	/**  Folder permissions of the user making the request */
	permissions: Permissions;
	/**  The top level root where the node resides */
	rootId: Maybe<Scalars['ID']['output']>;
	/**  Specific share of the current folder with the target user (if exists) */
	share: Maybe<Share>;
	/**  List of shares of the current folder (if they exist) */
	shares: Array<Maybe<Share>>;
	/**  Type of the node */
	type: NodeType;
	/**  Folder update timestamp */
	updated_at: Scalars['DateTime']['output'];
};

/**  Definition of the Folder type which implements the Node interface */
export type FolderChildrenArgs = {
	limit: Scalars['Int']['input'];
	page_token?: InputMaybe<Scalars['String']['input']>;
	sort: NodeSort;
};

/**  Definition of the Folder type which implements the Node interface */
export type FolderShareArgs = {
	share_target_id: Scalars['ID']['input'];
};

/**  Definition of the Folder type which implements the Node interface */
export type FolderSharesArgs = {
	cursor?: InputMaybe<Scalars['String']['input']>;
	limit: Scalars['Int']['input'];
	sorts?: InputMaybe<Array<ShareSort>>;
};

/**
 *  Definition of the Link type. It represents a public link of a specific node.
 *  Temporarily only a file can have a link
 */
export type Link = {
	__typename: 'Link';
	/**  Link access code. It must be 10 characters long. */
	access_code: Maybe<Scalars['String']['output']>;
	/**  Link creation timestamp. */
	created_at: Scalars['DateTime']['output'];
	/**  Link description. It must be shorter than 300 characters. */
	description: Maybe<Scalars['String']['output']>;
	/**  Link expiration timestamp. */
	expires_at: Maybe<Scalars['DateTime']['output']>;
	/**  Unique identifier of the link. */
	id: Scalars['ID']['output'];
	/**  Node related to this link. */
	node: File | Folder;
	/**
	 *  Full URL to access the related node. It will be returned only if the requester has the
	 *  <strong>can_share<strong> permission on the node. However anyone who has this link can
	 *  download the node.
	 */
	url: Maybe<Scalars['String']['output']>;
};

export type Mutation = {
	__typename: 'Mutation';
	cloneVersion: File;
	/**  Allows to copy a list of Nodes into a specified Folder. */
	copyNodes: Maybe<Array<File | Folder>>;
	/**
	 *  Allows to create a collaboration link for an existing node. A collaboration link can be created
	 *  only if the requester has the <strong>can_share<strong> permission on the specified node.
	 *  If the collaboration link already exists the system returns the already created one.
	 */
	createCollaborationLink: CollaborationLink;
	/**  <strong>Creates a new folder</strong> */
	createFolder: File | Folder;
	/**
	 *  Allows to create a public link for an existing node. A link can be created only if the requester has the
	 *  <strong>can_share<strong> permission on the specified node.
	 *  Optionally, an expiration timestamp and/or a description can be set.
	 */
	createLink: Link;
	/**
	 *  Allows to share an existing node to a user specifying the user permissions on that node,
	 *  and, optionally, an expiration timestamp.
	 */
	createShare: Share;
	/**
	 *  Allows to delete a list of collaboration links in batch. It returns:
	 *   - an array of IDs for each collaboration link removed;
	 *   - a list of errors for each collaboration link that could not be removed.
	 */
	deleteCollaborationLinks: Array<Maybe<Scalars['ID']['output']>>;
	/**
	 *  Allows to delete a list of links in batch. It returns an array of IDs for each removed link and
	 *  a list of errors for each link that could not be removed.
	 */
	deleteLinks: Array<Maybe<Scalars['ID']['output']>>;
	/**
	 *  Allows to delete a list of nodes. If the node is a folder then this operation removes the node and all its children,
	 *  if the node is a file then it removes all the related versions. This operation requires can_delete permission on
	 *  every node that should be deleted and it cannot be reverted.
	 */
	deleteNodes: Maybe<Array<Scalars['ID']['output']>>;
	deleteShare: Scalars['Boolean']['output'];
	/** TODO doc */
	deleteVersions: Array<Maybe<Scalars['Int']['output']>>;
	/**  Allows to flag a list of nodes. */
	flagNodes: Maybe<Array<Scalars['ID']['output']>>;
	keepVersions: Array<Maybe<Scalars['Int']['output']>>;
	/**
	 *  Allows to move a list of nodes into a folder destination. This operation requires write permissions on each file
	 *  should be moved and write permission on the destination folder otherwise it fails.
	 */
	moveNodes: Maybe<Array<File | Folder>>;
	/**  Restores a list of nodes. */
	restoreNodes: Maybe<Array<Maybe<File | Folder>>>;
	/**  Trashes a list of nodes. */
	trashNodes: Maybe<Array<Scalars['ID']['output']>>;
	/**
	 *  Allows to update the expiration timestamp and/or the description of an existing link.
	 *  An existing link can be updated only if the requester has the <strong>can_share<strong>
	 *  permission on the specified node.
	 */
	updateLink: Maybe<Link>;
	/**  <strong>Update an existing node</strong> */
	updateNode: File | Folder;
	/**  Allows to update the SharePermissions and the expiration timestamp of an existing share. */
	updateShare: Maybe<Share>;
};

export type MutationCloneVersionArgs = {
	node_id: Scalars['ID']['input'];
	version: Scalars['Int']['input'];
};

export type MutationCopyNodesArgs = {
	destination_id: Scalars['ID']['input'];
	node_ids?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export type MutationCreateCollaborationLinkArgs = {
	node_id: Scalars['ID']['input'];
	permission: SharePermission;
};

export type MutationCreateFolderArgs = {
	destination_id: Scalars['String']['input'];
	name: Scalars['String']['input'];
};

export type MutationCreateLinkArgs = {
	access_code?: InputMaybe<Scalars['String']['input']>;
	description?: InputMaybe<Scalars['String']['input']>;
	expires_at?: InputMaybe<Scalars['DateTime']['input']>;
	node_id: Scalars['ID']['input'];
};

export type MutationCreateShareArgs = {
	custom_message?: InputMaybe<Scalars['String']['input']>;
	expires_at?: InputMaybe<Scalars['DateTime']['input']>;
	node_id: Scalars['ID']['input'];
	permission: SharePermission;
	share_target_id: Scalars['ID']['input'];
};

export type MutationDeleteCollaborationLinksArgs = {
	collaboration_link_ids: Array<Scalars['ID']['input']>;
};

export type MutationDeleteLinksArgs = {
	link_ids: Array<Scalars['ID']['input']>;
};

export type MutationDeleteNodesArgs = {
	node_ids?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export type MutationDeleteShareArgs = {
	node_id: Scalars['ID']['input'];
	share_target_id: Scalars['ID']['input'];
};

export type MutationDeleteVersionsArgs = {
	node_id: Scalars['ID']['input'];
	versions?: InputMaybe<Array<Scalars['Int']['input']>>;
};

export type MutationFlagNodesArgs = {
	flag: Scalars['Boolean']['input'];
	node_ids?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export type MutationKeepVersionsArgs = {
	keep_forever: Scalars['Boolean']['input'];
	node_id: Scalars['ID']['input'];
	versions: Array<Scalars['Int']['input']>;
};

export type MutationMoveNodesArgs = {
	destination_id: Scalars['ID']['input'];
	node_ids?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export type MutationRestoreNodesArgs = {
	node_ids?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export type MutationTrashNodesArgs = {
	node_ids?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export type MutationUpdateLinkArgs = {
	access_code?: InputMaybe<Scalars['String']['input']>;
	description?: InputMaybe<Scalars['String']['input']>;
	expires_at?: InputMaybe<Scalars['DateTime']['input']>;
	link_id: Scalars['ID']['input'];
};

export type MutationUpdateNodeArgs = {
	description?: InputMaybe<Scalars['String']['input']>;
	flagged?: InputMaybe<Scalars['Boolean']['input']>;
	name?: InputMaybe<Scalars['String']['input']>;
	node_id: Scalars['String']['input'];
};

export type MutationUpdateShareArgs = {
	expires_at?: InputMaybe<Scalars['DateTime']['input']>;
	node_id: Scalars['ID']['input'];
	permission?: InputMaybe<SharePermission>;
	share_target_id: Scalars['ID']['input'];
};

/**  Definition of the Node interface */
export type Node = {
	/**
	 *  Returns all the CollaborationLinks of current node.
	 *  It can be maximum of 2 collaboration links:
	 *   - one that allows to auto-share the node with the READ+SHARE permission;
	 *   - one that allows to auto-share the node with the WRITE+SHARE permission.
	 */
	collaboration_links: Array<Maybe<CollaborationLink>>;
	/**  Node creation timestamp */
	created_at: Scalars['DateTime']['output'];
	/**  Creator of the node (it will be a User type when it will be implemented) */
	creator: User;
	/**  Description of the file/folder */
	description: Scalars['String']['output'];
	/**  True if the owner has marked the node as favourite, false otherwise */
	flagged: Scalars['Boolean']['output'];
	/**  Unique identifier of the node */
	id: Scalars['ID']['output'];
	/**  Last user who has edited the node (it will be a User type when it will be implemented) */
	last_editor: Maybe<User>;
	links: Array<Maybe<Link>>;
	/**  Name of the file/folder */
	name: Scalars['String']['output'];
	/**  Owner of the node (it will be a User type when it will be implemented) */
	owner: Maybe<User>;
	/**  Parent folder containing the node. The parent can be null when the current node is the root folder */
	parent: Maybe<File | Folder>;
	/**  Node permissions of the user making the request */
	permissions: Permissions;
	/**  The top level root where the node resides */
	rootId: Maybe<Scalars['ID']['output']>;
	/**  Specific share of the current node with the target user (if exists) */
	share: Maybe<Share>;
	/**  List of shares of the current node (if they exist) */
	shares: Array<Maybe<Share>>;
	/**  Type of the node */
	type: NodeType;
	/**  Node update timestamp */
	updated_at: Scalars['DateTime']['output'];
};

/**  Definition of the Node interface */
export type NodeShareArgs = {
	share_target_id: Scalars['ID']['input'];
};

/**  Definition of the Node interface */
export type NodeSharesArgs = {
	cursor?: InputMaybe<Scalars['String']['input']>;
	limit: Scalars['Int']['input'];
	sorts?: InputMaybe<Array<ShareSort>>;
};

export type NodePage = {
	__typename: 'NodePage';
	/** The list of nodes of the requested page */
	nodes: Array<Maybe<File | Folder>>;
	/**  The token to use as a cursor for requesting the next page of nodes */
	page_token: Maybe<Scalars['String']['output']>;
};

/**  Definition of the NodeSort enumerator. This is useful for sorting the result of a list of nodes. */
export enum NodeSort {
	LastEditorAsc = 'LAST_EDITOR_ASC',
	LastEditorDesc = 'LAST_EDITOR_DESC',
	NameAsc = 'NAME_ASC',
	NameDesc = 'NAME_DESC',
	OwnerAsc = 'OWNER_ASC',
	OwnerDesc = 'OWNER_DESC',
	SizeAsc = 'SIZE_ASC',
	SizeDesc = 'SIZE_DESC',
	TypeAsc = 'TYPE_ASC',
	TypeDesc = 'TYPE_DESC',
	UpdatedAtAsc = 'UPDATED_AT_ASC',
	UpdatedAtDesc = 'UPDATED_AT_DESC'
}

/** Definition of NodeType enumerator. This is used for discriminating the specific type of a node */
export enum NodeType {
	Application = 'APPLICATION',
	Audio = 'AUDIO',
	Folder = 'FOLDER',
	Image = 'IMAGE',
	Message = 'MESSAGE',
	Other = 'OTHER',
	Presentation = 'PRESENTATION',
	Root = 'ROOT',
	Spreadsheet = 'SPREADSHEET',
	Text = 'TEXT',
	Video = 'VIDEO'
}

/**
 * +---------------------------------+-------------------------------------------------------+
 * | Operation                       | Permission                                            |
 * +---------------------------------+-------------------------------------------------------+
 * | Create folder                   | Destination folder: Write and not trashed             |
 * +---------------------------------+-------------------------------------------------------+
 * | Upload node                     | Destination folder: Write and not trashed             |
 * +---------------------------------+-------------------------------------------------------+
 * | Copy node                       | Node to copy: Read                                    |
 * |                                 | Destination folder: Write and not trashed             |
 * +---------------------------------+-------------------------------------------------------+
 * | Move node                       | Node to move: Write                                   |
 * |                                 | Destination folder: Write and not trashed             |
 * +---------------------------------+-------------------------------------------------------+
 * | Download node                   | Read                                                  |
 * +---------------------------------+-------------------------------------------------------+
 * | Delete node                     | Only the owner can delete a node                      |
 * +---------------------------------+-------------------------------------------------------+
 * | List folder                     | Read Folder                                           |
 * +---------------------------------+-------------------------------------------------------+
 * | Get metadata                    | Read                                                  |
 * +---------------------------------+-------------------------------------------------------+
 * | Update metadata                 | Write                                                 |
 * +---------------------------------+-------------------------------------------------------+
 * | Trash/Untrash a node            | Write                                                 |
 * +---------------------------------+-------------------------------------------------------+
 * | Flag/Unflag a node              | Read                                                  |
 * +---------------------------------+-------------------------------------------------------+
 */
export type Permissions = {
	__typename: 'Permissions';
	can_add_version: Scalars['Boolean']['output'];
	can_change_link: Scalars['Boolean']['output'];
	can_change_share: Scalars['Boolean']['output'];
	can_delete: Scalars['Boolean']['output'];
	can_read: Scalars['Boolean']['output'];
	can_read_link: Scalars['Boolean']['output'];
	can_read_share: Scalars['Boolean']['output'];
	can_share: Scalars['Boolean']['output'];
	can_write_file: Scalars['Boolean']['output'];
	can_write_folder: Scalars['Boolean']['output'];
};

export type Query = {
	__typename: 'Query';
	/** <strong> Returns a NodePage based on the given criteria </strong> */
	findNodes: Maybe<NodePage>;
	getAccountByEmail: Maybe<Account>;
	getAccountsByEmail: Array<Maybe<Account>>;
	/**
	 *  Returns all the CollaborationLinks of the specified node.
	 *  The response is not paginated because each node can have a maximum of 2 collaboration links:
	 *   - one that allows to auto-share the node with the READ+SHARE permission;
	 *   - one that allows to auto-share the node with the WRITE+SHARE permission.
	 */
	getCollaborationLinks: Array<Maybe<CollaborationLink>>;
	getConfigs: Array<Maybe<Config>>;
	/**
	 *  Returns all the links of the specified node.
	 *  The response is not paginated because each node can have a maximum of 50 links.
	 */
	getLinks: Array<Maybe<Link>>;
	/**  <strong>Returns the attributes of the node specified by ID</strong> */
	getNode: Maybe<File | Folder>;
	/**
	 *  <strong> Returns the list of nodes corresponding to the path of a node</strong>
	 *  The path is ordered and returns from the highest visible one to the requested node.
	 */
	getPath: Array<Maybe<File | Folder>>;
	/**  Returns the list of all root folders */
	getRootsList: Array<Maybe<Root>>;
	/**  Returns the attributes of the specified share */
	getShare: Maybe<Share>;
	getUserById: Maybe<User>;
	getVersions: Array<Maybe<File>>;
};

export type QueryFindNodesArgs = {
	cascade?: InputMaybe<Scalars['Boolean']['input']>;
	direct_share?: InputMaybe<Scalars['Boolean']['input']>;
	flagged?: InputMaybe<Scalars['Boolean']['input']>;
	folder_id?: InputMaybe<Scalars['String']['input']>;
	keywords?: InputMaybe<Array<Scalars['String']['input']>>;
	limit?: InputMaybe<Scalars['Int']['input']>;
	owner_id?: InputMaybe<Scalars['String']['input']>;
	page_token?: InputMaybe<Scalars['String']['input']>;
	shared_by_me?: InputMaybe<Scalars['Boolean']['input']>;
	shared_with_me?: InputMaybe<Scalars['Boolean']['input']>;
	sort?: InputMaybe<NodeSort>;
	type?: InputMaybe<NodeType>;
};

export type QueryGetAccountByEmailArgs = {
	email: Scalars['String']['input'];
};

export type QueryGetAccountsByEmailArgs = {
	emails: Array<Scalars['String']['input']>;
};

export type QueryGetCollaborationLinksArgs = {
	node_id: Scalars['ID']['input'];
};

export type QueryGetLinksArgs = {
	node_id: Scalars['ID']['input'];
};

export type QueryGetNodeArgs = {
	node_id: Scalars['ID']['input'];
	version?: InputMaybe<Scalars['Int']['input']>;
};

export type QueryGetPathArgs = {
	node_id: Scalars['ID']['input'];
};

export type QueryGetShareArgs = {
	node_id: Scalars['ID']['input'];
	share_target_id: Scalars['ID']['input'];
};

export type QueryGetUserByIdArgs = {
	user_id: Scalars['ID']['input'];
};

export type QueryGetVersionsArgs = {
	node_id: Scalars['ID']['input'];
	versions?: InputMaybe<Array<Scalars['Int']['input']>>;
};

/**  Definition of the type Root. Represents a root folder */
export type Root = {
	__typename: 'Root';
	/**  Unique identifier of the root */
	id: Scalars['ID']['output'];
	/**  Name of the root */
	name: Scalars['String']['output'];
};

/**  Definition of the Share type. It represents a share between a node and a user. */
export type Share = {
	__typename: 'Share';
	/**  Share creation timestamp */
	created_at: Scalars['DateTime']['output'];
	/**  Share expiration timestamp */
	expires_at: Maybe<Scalars['DateTime']['output']>;
	/**  Node shared */
	node: File | Folder;
	/**  User permission for the node */
	permission: SharePermission;
	/**  User to whom a node has been shared */
	share_target: Maybe<SharedTarget>;
};

/**  The SharePermissions enumerator represents the permissions of a node shared with a user */
export enum SharePermission {
	ReadAndShare = 'READ_AND_SHARE',
	ReadAndWrite = 'READ_AND_WRITE',
	ReadOnly = 'READ_ONLY',
	ReadWriteAndShare = 'READ_WRITE_AND_SHARE'
}

/**  Definition of the ShareSort enumerator. This is useful for sorting the result of a list of shares. */
export enum ShareSort {
	CreationAsc = 'CREATION_ASC',
	CreationDesc = 'CREATION_DESC',
	ExpirationAsc = 'EXPIRATION_ASC',
	ExpirationDesc = 'EXPIRATION_DESC',
	/**  The order is ascending: this means that first are shown the shares with fewer permissions. */
	SharePermissionsAsc = 'SHARE_PERMISSIONS_ASC',
	/**  The order is descending: this means that first are shown the shares with more permissions. */
	SharePermissionsDesc = 'SHARE_PERMISSIONS_DESC',
	/**  The order is based on the target user identifier and not on his email or display name. */
	TargetUserAsc = 'TARGET_USER_ASC',
	/**  The order is based on the target user identifier and not on his email or display name. */
	TargetUserDesc = 'TARGET_USER_DESC'
}

export type SharedTarget = DistributionList | User;

/**  Definition of the User type */
export type User = {
	__typename: 'User';
	/**  Email of the user */
	email: Scalars['String']['output'];
	/**  Full name of the user */
	full_name: Scalars['String']['output'];
	/**  Unique identifier of the folder */
	id: Scalars['ID']['output'];
};

export type ResolverTypeWrapper<T> = Promise<T> | T;

export type ResolverWithResolve<TResult, TParent, TContext, TArgs> = {
	resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};
export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> =
	| ResolverFn<TResult, TParent, TContext, TArgs>
	| ResolverWithResolve<TResult, TParent, TContext, TArgs>;

export type ResolverFn<TResult, TParent, TContext, TArgs> = (
	parent: TParent,
	args: TArgs,
	context: TContext,
	info: GraphQLResolveInfo
) => Promise<TResult> | TResult;

export type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (
	parent: TParent,
	args: TArgs,
	context: TContext,
	info: GraphQLResolveInfo
) => AsyncIterable<TResult> | Promise<AsyncIterable<TResult>>;

export type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (
	parent: TParent,
	args: TArgs,
	context: TContext,
	info: GraphQLResolveInfo
) => TResult | Promise<TResult>;

export interface SubscriptionSubscriberObject<
	TResult,
	TKey extends string,
	TParent,
	TContext,
	TArgs
> {
	subscribe: SubscriptionSubscribeFn<{ [key in TKey]: TResult }, TParent, TContext, TArgs>;
	resolve?: SubscriptionResolveFn<TResult, { [key in TKey]: TResult }, TContext, TArgs>;
}

export interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {
	subscribe: SubscriptionSubscribeFn<any, TParent, TContext, TArgs>;
	resolve: SubscriptionResolveFn<TResult, any, TContext, TArgs>;
}

export type SubscriptionObject<TResult, TKey extends string, TParent, TContext, TArgs> =
	| SubscriptionSubscriberObject<TResult, TKey, TParent, TContext, TArgs>
	| SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;

export type SubscriptionResolver<
	TResult,
	TKey extends string,
	TParent = {},
	TContext = {},
	TArgs = {}
> =
	| ((...args: any[]) => SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>)
	| SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>;

export type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (
	parent: TParent,
	context: TContext,
	info: GraphQLResolveInfo
) => Maybe<TTypes> | Promise<Maybe<TTypes>>;

export type IsTypeOfResolverFn<T = {}, TContext = {}> = (
	obj: T,
	context: TContext,
	info: GraphQLResolveInfo
) => boolean | Promise<boolean>;

export type NextResolverFn<T> = () => Promise<T>;

export type DirectiveResolverFn<TResult = {}, TParent = {}, TContext = {}, TArgs = {}> = (
	next: NextResolverFn<TResult>,
	parent: TParent,
	args: TArgs,
	context: TContext,
	info: GraphQLResolveInfo
) => TResult | Promise<TResult>;

/** Mapping of union types */
export type ResolversUnionTypes<_RefType extends Record<string, unknown>> = {
	Account: DistributionList | User;
	SharedTarget: DistributionList | User;
};

/** Mapping of interface types */
export type ResolversInterfaceTypes<_RefType extends Record<string, unknown>> = {
	Node:
		| (Omit<File, 'collaboration_links' | 'links' | 'parent' | 'share' | 'shares'> & {
				collaboration_links: Array<Maybe<_RefType['CollaborationLink']>>;
				links: Array<Maybe<_RefType['Link']>>;
				parent: Maybe<_RefType['Node']>;
				share: Maybe<_RefType['Share']>;
				shares: Array<Maybe<_RefType['Share']>>;
		  })
		| (Omit<
				Folder,
				'children' | 'collaboration_links' | 'links' | 'parent' | 'share' | 'shares'
		  > & {
				children: _RefType['NodePage'];
				collaboration_links: Array<Maybe<_RefType['CollaborationLink']>>;
				links: Array<Maybe<_RefType['Link']>>;
				parent: Maybe<_RefType['Node']>;
				share: Maybe<_RefType['Share']>;
				shares: Array<Maybe<_RefType['Share']>>;
		  });
};

/** Mapping between all available schema types and the resolvers types */
export type ResolversTypes = {
	Account: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['Account']>;
	Boolean: ResolverTypeWrapper<Scalars['Boolean']['output']>;
	CollaborationLink: ResolverTypeWrapper<
		Omit<CollaborationLink, 'node'> & { node: ResolversTypes['Node'] }
	>;
	Config: ResolverTypeWrapper<Config>;
	DateTime: ResolverTypeWrapper<Scalars['DateTime']['output']>;
	DistributionList: ResolverTypeWrapper<DistributionList>;
	File: ResolverTypeWrapper<
		Omit<File, 'collaboration_links' | 'links' | 'parent' | 'share' | 'shares'> & {
			collaboration_links: Array<Maybe<ResolversTypes['CollaborationLink']>>;
			links: Array<Maybe<ResolversTypes['Link']>>;
			parent: Maybe<ResolversTypes['Node']>;
			share: Maybe<ResolversTypes['Share']>;
			shares: Array<Maybe<ResolversTypes['Share']>>;
		}
	>;
	Float: ResolverTypeWrapper<Scalars['Float']['output']>;
	Folder: ResolverTypeWrapper<
		Omit<Folder, 'children' | 'collaboration_links' | 'links' | 'parent' | 'share' | 'shares'> & {
			children: ResolversTypes['NodePage'];
			collaboration_links: Array<Maybe<ResolversTypes['CollaborationLink']>>;
			links: Array<Maybe<ResolversTypes['Link']>>;
			parent: Maybe<ResolversTypes['Node']>;
			share: Maybe<ResolversTypes['Share']>;
			shares: Array<Maybe<ResolversTypes['Share']>>;
		}
	>;
	ID: ResolverTypeWrapper<Scalars['ID']['output']>;
	Int: ResolverTypeWrapper<Scalars['Int']['output']>;
	Link: ResolverTypeWrapper<Omit<Link, 'node'> & { node: ResolversTypes['Node'] }>;
	Mutation: ResolverTypeWrapper<{}>;
	Node: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['Node']>;
	NodePage: ResolverTypeWrapper<
		Omit<NodePage, 'nodes'> & { nodes: Array<Maybe<ResolversTypes['Node']>> }
	>;
	NodeSort: NodeSort;
	NodeType: NodeType;
	Permissions: ResolverTypeWrapper<Permissions>;
	Query: ResolverTypeWrapper<{}>;
	Root: ResolverTypeWrapper<Root>;
	Share: ResolverTypeWrapper<
		Omit<Share, 'node' | 'share_target'> & {
			node: ResolversTypes['Node'];
			share_target: Maybe<ResolversTypes['SharedTarget']>;
		}
	>;
	SharePermission: SharePermission;
	ShareSort: ShareSort;
	SharedTarget: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SharedTarget']>;
	String: ResolverTypeWrapper<Scalars['String']['output']>;
	User: ResolverTypeWrapper<User>;
};

/** Mapping between all available schema types and the resolvers parents */
export type ResolversParentTypes = {
	Account: ResolversUnionTypes<ResolversParentTypes>['Account'];
	Boolean: Scalars['Boolean']['output'];
	CollaborationLink: Omit<CollaborationLink, 'node'> & { node: ResolversParentTypes['Node'] };
	Config: Config;
	DateTime: Scalars['DateTime']['output'];
	DistributionList: DistributionList;
	File: Omit<File, 'collaboration_links' | 'links' | 'parent' | 'share' | 'shares'> & {
		collaboration_links: Array<Maybe<ResolversParentTypes['CollaborationLink']>>;
		links: Array<Maybe<ResolversParentTypes['Link']>>;
		parent: Maybe<ResolversParentTypes['Node']>;
		share: Maybe<ResolversParentTypes['Share']>;
		shares: Array<Maybe<ResolversParentTypes['Share']>>;
	};
	Float: Scalars['Float']['output'];
	Folder: Omit<
		Folder,
		'children' | 'collaboration_links' | 'links' | 'parent' | 'share' | 'shares'
	> & {
		children: ResolversParentTypes['NodePage'];
		collaboration_links: Array<Maybe<ResolversParentTypes['CollaborationLink']>>;
		links: Array<Maybe<ResolversParentTypes['Link']>>;
		parent: Maybe<ResolversParentTypes['Node']>;
		share: Maybe<ResolversParentTypes['Share']>;
		shares: Array<Maybe<ResolversParentTypes['Share']>>;
	};
	ID: Scalars['ID']['output'];
	Int: Scalars['Int']['output'];
	Link: Omit<Link, 'node'> & { node: ResolversParentTypes['Node'] };
	Mutation: {};
	Node: ResolversInterfaceTypes<ResolversParentTypes>['Node'];
	NodePage: Omit<NodePage, 'nodes'> & { nodes: Array<Maybe<ResolversParentTypes['Node']>> };
	Permissions: Permissions;
	Query: {};
	Root: Root;
	Share: Omit<Share, 'node' | 'share_target'> & {
		node: ResolversParentTypes['Node'];
		share_target: Maybe<ResolversParentTypes['SharedTarget']>;
	};
	SharedTarget: ResolversUnionTypes<ResolversParentTypes>['SharedTarget'];
	String: Scalars['String']['output'];
	User: User;
};

export type AccountResolvers<
	ContextType = any,
	ParentType extends ResolversParentTypes['Account'] = ResolversParentTypes['Account']
> = {
	__resolveType: TypeResolveFn<'DistributionList' | 'User', ParentType, ContextType>;
};

export type CollaborationLinkResolvers<
	ContextType = any,
	ParentType extends
		ResolversParentTypes['CollaborationLink'] = ResolversParentTypes['CollaborationLink']
> = {
	created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
	id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
	node?: Resolver<ResolversTypes['Node'], ParentType, ContextType>;
	permission?: Resolver<ResolversTypes['SharePermission'], ParentType, ContextType>;
	url?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
	__isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ConfigResolvers<
	ContextType = any,
	ParentType extends ResolversParentTypes['Config'] = ResolversParentTypes['Config']
> = {
	name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
	value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
	__isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface DateTimeScalarConfig
	extends GraphQLScalarTypeConfig<ResolversTypes['DateTime'], any> {
	name: 'DateTime';
}

export type DistributionListResolvers<
	ContextType = any,
	ParentType extends
		ResolversParentTypes['DistributionList'] = ResolversParentTypes['DistributionList']
> = {
	id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
	name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
	users?: Resolver<
		Array<Maybe<ResolversTypes['User']>>,
		ParentType,
		ContextType,
		RequireFields<DistributionListUsersArgs, 'limit'>
	>;
	__isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FileResolvers<
	ContextType = any,
	ParentType extends ResolversParentTypes['File'] = ResolversParentTypes['File']
> = {
	cloned_from_version?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
	collaboration_links?: Resolver<
		Array<Maybe<ResolversTypes['CollaborationLink']>>,
		ParentType,
		ContextType
	>;
	created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
	creator?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
	description?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
	extension?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
	flagged?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
	id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
	keep_forever?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
	last_editor?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
	links?: Resolver<Array<Maybe<ResolversTypes['Link']>>, ParentType, ContextType>;
	mime_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
	name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
	owner?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
	parent?: Resolver<Maybe<ResolversTypes['Node']>, ParentType, ContextType>;
	permissions?: Resolver<ResolversTypes['Permissions'], ParentType, ContextType>;
	rootId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
	share?: Resolver<
		Maybe<ResolversTypes['Share']>,
		ParentType,
		ContextType,
		RequireFields<FileShareArgs, 'share_target_id'>
	>;
	shares?: Resolver<
		Array<Maybe<ResolversTypes['Share']>>,
		ParentType,
		ContextType,
		RequireFields<FileSharesArgs, 'limit'>
	>;
	size?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
	type?: Resolver<ResolversTypes['NodeType'], ParentType, ContextType>;
	updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
	version?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
	__isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FolderResolvers<
	ContextType = any,
	ParentType extends ResolversParentTypes['Folder'] = ResolversParentTypes['Folder']
> = {
	children?: Resolver<
		ResolversTypes['NodePage'],
		ParentType,
		ContextType,
		RequireFields<FolderChildrenArgs, 'limit' | 'sort'>
	>;
	collaboration_links?: Resolver<
		Array<Maybe<ResolversTypes['CollaborationLink']>>,
		ParentType,
		ContextType
	>;
	created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
	creator?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
	description?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
	flagged?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
	id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
	last_editor?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
	links?: Resolver<Array<Maybe<ResolversTypes['Link']>>, ParentType, ContextType>;
	name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
	owner?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
	parent?: Resolver<Maybe<ResolversTypes['Node']>, ParentType, ContextType>;
	permissions?: Resolver<ResolversTypes['Permissions'], ParentType, ContextType>;
	rootId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
	share?: Resolver<
		Maybe<ResolversTypes['Share']>,
		ParentType,
		ContextType,
		RequireFields<FolderShareArgs, 'share_target_id'>
	>;
	shares?: Resolver<
		Array<Maybe<ResolversTypes['Share']>>,
		ParentType,
		ContextType,
		RequireFields<FolderSharesArgs, 'limit'>
	>;
	type?: Resolver<ResolversTypes['NodeType'], ParentType, ContextType>;
	updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
	__isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LinkResolvers<
	ContextType = any,
	ParentType extends ResolversParentTypes['Link'] = ResolversParentTypes['Link']
> = {
	access_code?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
	created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
	description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
	expires_at?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
	id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
	node?: Resolver<ResolversTypes['Node'], ParentType, ContextType>;
	url?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
	__isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MutationResolvers<
	ContextType = any,
	ParentType extends ResolversParentTypes['Mutation'] = ResolversParentTypes['Mutation']
> = {
	cloneVersion?: Resolver<
		ResolversTypes['File'],
		ParentType,
		ContextType,
		RequireFields<MutationCloneVersionArgs, 'node_id' | 'version'>
	>;
	copyNodes?: Resolver<
		Maybe<Array<ResolversTypes['Node']>>,
		ParentType,
		ContextType,
		RequireFields<MutationCopyNodesArgs, 'destination_id'>
	>;
	createCollaborationLink?: Resolver<
		ResolversTypes['CollaborationLink'],
		ParentType,
		ContextType,
		RequireFields<MutationCreateCollaborationLinkArgs, 'node_id' | 'permission'>
	>;
	createFolder?: Resolver<
		ResolversTypes['Node'],
		ParentType,
		ContextType,
		RequireFields<MutationCreateFolderArgs, 'destination_id' | 'name'>
	>;
	createLink?: Resolver<
		ResolversTypes['Link'],
		ParentType,
		ContextType,
		RequireFields<MutationCreateLinkArgs, 'node_id'>
	>;
	createShare?: Resolver<
		ResolversTypes['Share'],
		ParentType,
		ContextType,
		RequireFields<MutationCreateShareArgs, 'node_id' | 'permission' | 'share_target_id'>
	>;
	deleteCollaborationLinks?: Resolver<
		Array<Maybe<ResolversTypes['ID']>>,
		ParentType,
		ContextType,
		RequireFields<MutationDeleteCollaborationLinksArgs, 'collaboration_link_ids'>
	>;
	deleteLinks?: Resolver<
		Array<Maybe<ResolversTypes['ID']>>,
		ParentType,
		ContextType,
		RequireFields<MutationDeleteLinksArgs, 'link_ids'>
	>;
	deleteNodes?: Resolver<
		Maybe<Array<ResolversTypes['ID']>>,
		ParentType,
		ContextType,
		Partial<MutationDeleteNodesArgs>
	>;
	deleteShare?: Resolver<
		ResolversTypes['Boolean'],
		ParentType,
		ContextType,
		RequireFields<MutationDeleteShareArgs, 'node_id' | 'share_target_id'>
	>;
	deleteVersions?: Resolver<
		Array<Maybe<ResolversTypes['Int']>>,
		ParentType,
		ContextType,
		RequireFields<MutationDeleteVersionsArgs, 'node_id'>
	>;
	flagNodes?: Resolver<
		Maybe<Array<ResolversTypes['ID']>>,
		ParentType,
		ContextType,
		RequireFields<MutationFlagNodesArgs, 'flag'>
	>;
	keepVersions?: Resolver<
		Array<Maybe<ResolversTypes['Int']>>,
		ParentType,
		ContextType,
		RequireFields<MutationKeepVersionsArgs, 'keep_forever' | 'node_id' | 'versions'>
	>;
	moveNodes?: Resolver<
		Maybe<Array<ResolversTypes['Node']>>,
		ParentType,
		ContextType,
		RequireFields<MutationMoveNodesArgs, 'destination_id'>
	>;
	restoreNodes?: Resolver<
		Maybe<Array<Maybe<ResolversTypes['Node']>>>,
		ParentType,
		ContextType,
		Partial<MutationRestoreNodesArgs>
	>;
	trashNodes?: Resolver<
		Maybe<Array<ResolversTypes['ID']>>,
		ParentType,
		ContextType,
		Partial<MutationTrashNodesArgs>
	>;
	updateLink?: Resolver<
		Maybe<ResolversTypes['Link']>,
		ParentType,
		ContextType,
		RequireFields<MutationUpdateLinkArgs, 'link_id'>
	>;
	updateNode?: Resolver<
		ResolversTypes['Node'],
		ParentType,
		ContextType,
		RequireFields<MutationUpdateNodeArgs, 'node_id'>
	>;
	updateShare?: Resolver<
		Maybe<ResolversTypes['Share']>,
		ParentType,
		ContextType,
		RequireFields<MutationUpdateShareArgs, 'node_id' | 'share_target_id'>
	>;
};

export type NodeResolvers<
	ContextType = any,
	ParentType extends ResolversParentTypes['Node'] = ResolversParentTypes['Node']
> = {
	__resolveType: TypeResolveFn<'File' | 'Folder', ParentType, ContextType>;
	collaboration_links?: Resolver<
		Array<Maybe<ResolversTypes['CollaborationLink']>>,
		ParentType,
		ContextType
	>;
	created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
	creator?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
	description?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
	flagged?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
	id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
	last_editor?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
	links?: Resolver<Array<Maybe<ResolversTypes['Link']>>, ParentType, ContextType>;
	name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
	owner?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
	parent?: Resolver<Maybe<ResolversTypes['Node']>, ParentType, ContextType>;
	permissions?: Resolver<ResolversTypes['Permissions'], ParentType, ContextType>;
	rootId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
	share?: Resolver<
		Maybe<ResolversTypes['Share']>,
		ParentType,
		ContextType,
		RequireFields<NodeShareArgs, 'share_target_id'>
	>;
	shares?: Resolver<
		Array<Maybe<ResolversTypes['Share']>>,
		ParentType,
		ContextType,
		RequireFields<NodeSharesArgs, 'limit'>
	>;
	type?: Resolver<ResolversTypes['NodeType'], ParentType, ContextType>;
	updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
};

export type NodePageResolvers<
	ContextType = any,
	ParentType extends ResolversParentTypes['NodePage'] = ResolversParentTypes['NodePage']
> = {
	nodes?: Resolver<Array<Maybe<ResolversTypes['Node']>>, ParentType, ContextType>;
	page_token?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
	__isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PermissionsResolvers<
	ContextType = any,
	ParentType extends ResolversParentTypes['Permissions'] = ResolversParentTypes['Permissions']
> = {
	can_add_version?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
	can_change_link?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
	can_change_share?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
	can_delete?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
	can_read?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
	can_read_link?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
	can_read_share?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
	can_share?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
	can_write_file?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
	can_write_folder?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
	__isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type QueryResolvers<
	ContextType = any,
	ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']
> = {
	findNodes?: Resolver<
		Maybe<ResolversTypes['NodePage']>,
		ParentType,
		ContextType,
		Partial<QueryFindNodesArgs>
	>;
	getAccountByEmail?: Resolver<
		Maybe<ResolversTypes['Account']>,
		ParentType,
		ContextType,
		RequireFields<QueryGetAccountByEmailArgs, 'email'>
	>;
	getAccountsByEmail?: Resolver<
		Array<Maybe<ResolversTypes['Account']>>,
		ParentType,
		ContextType,
		RequireFields<QueryGetAccountsByEmailArgs, 'emails'>
	>;
	getCollaborationLinks?: Resolver<
		Array<Maybe<ResolversTypes['CollaborationLink']>>,
		ParentType,
		ContextType,
		RequireFields<QueryGetCollaborationLinksArgs, 'node_id'>
	>;
	getConfigs?: Resolver<Array<Maybe<ResolversTypes['Config']>>, ParentType, ContextType>;
	getLinks?: Resolver<
		Array<Maybe<ResolversTypes['Link']>>,
		ParentType,
		ContextType,
		RequireFields<QueryGetLinksArgs, 'node_id'>
	>;
	getNode?: Resolver<
		Maybe<ResolversTypes['Node']>,
		ParentType,
		ContextType,
		RequireFields<QueryGetNodeArgs, 'node_id'>
	>;
	getPath?: Resolver<
		Array<Maybe<ResolversTypes['Node']>>,
		ParentType,
		ContextType,
		RequireFields<QueryGetPathArgs, 'node_id'>
	>;
	getRootsList?: Resolver<Array<Maybe<ResolversTypes['Root']>>, ParentType, ContextType>;
	getShare?: Resolver<
		Maybe<ResolversTypes['Share']>,
		ParentType,
		ContextType,
		RequireFields<QueryGetShareArgs, 'node_id' | 'share_target_id'>
	>;
	getUserById?: Resolver<
		Maybe<ResolversTypes['User']>,
		ParentType,
		ContextType,
		RequireFields<QueryGetUserByIdArgs, 'user_id'>
	>;
	getVersions?: Resolver<
		Array<Maybe<ResolversTypes['File']>>,
		ParentType,
		ContextType,
		RequireFields<QueryGetVersionsArgs, 'node_id'>
	>;
};

export type RootResolvers<
	ContextType = any,
	ParentType extends ResolversParentTypes['Root'] = ResolversParentTypes['Root']
> = {
	id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
	name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
	__isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ShareResolvers<
	ContextType = any,
	ParentType extends ResolversParentTypes['Share'] = ResolversParentTypes['Share']
> = {
	created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
	expires_at?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
	node?: Resolver<ResolversTypes['Node'], ParentType, ContextType>;
	permission?: Resolver<ResolversTypes['SharePermission'], ParentType, ContextType>;
	share_target?: Resolver<Maybe<ResolversTypes['SharedTarget']>, ParentType, ContextType>;
	__isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SharedTargetResolvers<
	ContextType = any,
	ParentType extends ResolversParentTypes['SharedTarget'] = ResolversParentTypes['SharedTarget']
> = {
	__resolveType: TypeResolveFn<'DistributionList' | 'User', ParentType, ContextType>;
};

export type UserResolvers<
	ContextType = any,
	ParentType extends ResolversParentTypes['User'] = ResolversParentTypes['User']
> = {
	email?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
	full_name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
	id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
	__isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type Resolvers<ContextType = any> = {
	Account?: AccountResolvers<ContextType>;
	CollaborationLink?: CollaborationLinkResolvers<ContextType>;
	Config?: ConfigResolvers<ContextType>;
	DateTime?: GraphQLScalarType;
	DistributionList?: DistributionListResolvers<ContextType>;
	File?: FileResolvers<ContextType>;
	Folder?: FolderResolvers<ContextType>;
	Link?: LinkResolvers<ContextType>;
	Mutation?: MutationResolvers<ContextType>;
	Node?: NodeResolvers<ContextType>;
	NodePage?: NodePageResolvers<ContextType>;
	Permissions?: PermissionsResolvers<ContextType>;
	Query?: QueryResolvers<ContextType>;
	Root?: RootResolvers<ContextType>;
	Share?: ShareResolvers<ContextType>;
	SharedTarget?: SharedTargetResolvers<ContextType>;
	User?: UserResolvers<ContextType>;
};
