/*
 * SPDX-FileCopyrightText: 2023 Zextras <https://www.zextras.com>
 *
 * SPDX-License-Identifier: AGPL-3.0-only
 */
/* eslint-disable camelcase,no-shadow,@typescript-eslint/ban-types */
// THIS FILE IS AUTOGENERATED BY GRAPHQL-CODEGEN. DO NOT EDIT!
import { GraphQLResolveInfo, GraphQLScalarType, GraphQLScalarTypeConfig } from 'graphql';

export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
export type RequireFields<T, K extends keyof T> = Omit<T, K> & { [P in K]-?: NonNullable<T[P]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
	ID: string;
	String: string;
	Boolean: boolean;
	Int: number;
	Float: number;
	DateTime: number;
};

export type Account = DistributionList | User;

export type CollaborationLink = {
	__typename?: 'CollaborationLink';
	created_at: Scalars['DateTime'];
	id: Scalars['ID'];
	node: File | Folder;
	permission: SharePermission;
	url: Scalars['String'];
};

export type Config = {
	__typename?: 'Config';
	name: Scalars['String'];
	value: Scalars['String'];
};

export type DistributionList = {
	__typename?: 'DistributionList';
	id: Scalars['ID'];
	name: Scalars['String'];
	users: Array<Maybe<User>>;
};

export type DistributionListUsersArgs = {
	cursor?: InputMaybe<Scalars['String']>;
	limit: Scalars['Int'];
};

export type File = Node & {
	__typename?: 'File';
	cloned_from_version?: Maybe<Scalars['Int']>;
	collaboration_links: Array<Maybe<CollaborationLink>>;
	created_at: Scalars['DateTime'];
	creator: User;
	description: Scalars['String'];
	extension?: Maybe<Scalars['String']>;
	flagged: Scalars['Boolean'];
	id: Scalars['ID'];
	keep_forever: Scalars['Boolean'];
	last_editor?: Maybe<User>;
	links: Array<Maybe<Link>>;
	mime_type: Scalars['String'];
	name: Scalars['String'];
	owner?: Maybe<User>;
	parent?: Maybe<File | Folder>;
	permissions: Permissions;
	rootId?: Maybe<Scalars['ID']>;
	share?: Maybe<Share>;
	shares: Array<Maybe<Share>>;
	size: Scalars['Float'];
	type: NodeType;
	updated_at: Scalars['DateTime'];
	version: Scalars['Int'];
};

export type FileShareArgs = {
	share_target_id: Scalars['ID'];
};

export type FileSharesArgs = {
	cursor?: InputMaybe<Scalars['String']>;
	limit: Scalars['Int'];
	sorts?: InputMaybe<Array<ShareSort>>;
};

export type Folder = Node & {
	__typename?: 'Folder';
	children: NodePage;
	collaboration_links: Array<Maybe<CollaborationLink>>;
	created_at: Scalars['DateTime'];
	creator: User;
	description: Scalars['String'];
	flagged: Scalars['Boolean'];
	id: Scalars['ID'];
	last_editor?: Maybe<User>;
	links: Array<Maybe<Link>>;
	name: Scalars['String'];
	owner?: Maybe<User>;
	parent?: Maybe<File | Folder>;
	permissions: Permissions;
	rootId?: Maybe<Scalars['ID']>;
	share?: Maybe<Share>;
	shares: Array<Maybe<Share>>;
	type: NodeType;
	updated_at: Scalars['DateTime'];
};

export type FolderChildrenArgs = {
	limit: Scalars['Int'];
	page_token?: InputMaybe<Scalars['String']>;
	sort: NodeSort;
};

export type FolderShareArgs = {
	share_target_id: Scalars['ID'];
};

export type FolderSharesArgs = {
	cursor?: InputMaybe<Scalars['String']>;
	limit: Scalars['Int'];
	sorts?: InputMaybe<Array<ShareSort>>;
};

export type Link = {
	__typename?: 'Link';
	created_at: Scalars['DateTime'];
	description?: Maybe<Scalars['String']>;
	expires_at?: Maybe<Scalars['DateTime']>;
	id: Scalars['ID'];
	node: File | Folder;
	url?: Maybe<Scalars['String']>;
};

export type Mutation = {
	__typename?: 'Mutation';
	cloneVersion: File;
	copyNodes?: Maybe<Array<File | Folder>>;
	createCollaborationLink: CollaborationLink;
	createFolder: File | Folder;
	createLink: Link;
	createShare: Share;
	deleteCollaborationLinks: Array<Maybe<Scalars['ID']>>;
	deleteLinks: Array<Maybe<Scalars['ID']>>;
	deleteNodes?: Maybe<Array<Scalars['ID']>>;
	deleteShare: Scalars['Boolean'];
	deleteVersions: Array<Maybe<Scalars['Int']>>;
	flagNodes?: Maybe<Array<Scalars['ID']>>;
	keepVersions: Array<Maybe<Scalars['Int']>>;
	moveNodes?: Maybe<Array<File | Folder>>;
	restoreNodes?: Maybe<Array<Maybe<File | Folder>>>;
	trashNodes?: Maybe<Array<Scalars['ID']>>;
	updateLink?: Maybe<Link>;
	updateNode: File | Folder;
	updateShare?: Maybe<Share>;
};

export type MutationCloneVersionArgs = {
	node_id: Scalars['ID'];
	version: Scalars['Int'];
};

export type MutationCopyNodesArgs = {
	destination_id: Scalars['ID'];
	node_ids?: InputMaybe<Array<Scalars['ID']>>;
};

export type MutationCreateCollaborationLinkArgs = {
	node_id: Scalars['ID'];
	permission: SharePermission;
};

export type MutationCreateFolderArgs = {
	destination_id: Scalars['String'];
	name: Scalars['String'];
};

export type MutationCreateLinkArgs = {
	description?: InputMaybe<Scalars['String']>;
	expires_at?: InputMaybe<Scalars['DateTime']>;
	node_id: Scalars['ID'];
};

export type MutationCreateShareArgs = {
	custom_message?: InputMaybe<Scalars['String']>;
	expires_at?: InputMaybe<Scalars['DateTime']>;
	node_id: Scalars['ID'];
	permission: SharePermission;
	share_target_id: Scalars['ID'];
};

export type MutationDeleteCollaborationLinksArgs = {
	collaboration_link_ids: Array<Scalars['ID']>;
};

export type MutationDeleteLinksArgs = {
	link_ids: Array<Scalars['ID']>;
};

export type MutationDeleteNodesArgs = {
	node_ids?: InputMaybe<Array<Scalars['ID']>>;
};

export type MutationDeleteShareArgs = {
	node_id: Scalars['ID'];
	share_target_id: Scalars['ID'];
};

export type MutationDeleteVersionsArgs = {
	node_id: Scalars['ID'];
	versions?: InputMaybe<Array<Scalars['Int']>>;
};

export type MutationFlagNodesArgs = {
	flag: Scalars['Boolean'];
	node_ids?: InputMaybe<Array<Scalars['ID']>>;
};

export type MutationKeepVersionsArgs = {
	keep_forever: Scalars['Boolean'];
	node_id: Scalars['ID'];
	versions: Array<Scalars['Int']>;
};

export type MutationMoveNodesArgs = {
	destination_id: Scalars['ID'];
	node_ids?: InputMaybe<Array<Scalars['ID']>>;
};

export type MutationRestoreNodesArgs = {
	node_ids?: InputMaybe<Array<Scalars['ID']>>;
};

export type MutationTrashNodesArgs = {
	node_ids?: InputMaybe<Array<Scalars['ID']>>;
};

export type MutationUpdateLinkArgs = {
	description?: InputMaybe<Scalars['String']>;
	expires_at?: InputMaybe<Scalars['DateTime']>;
	link_id: Scalars['ID'];
};

export type MutationUpdateNodeArgs = {
	description?: InputMaybe<Scalars['String']>;
	flagged?: InputMaybe<Scalars['Boolean']>;
	name?: InputMaybe<Scalars['String']>;
	node_id: Scalars['String'];
};

export type MutationUpdateShareArgs = {
	expires_at?: InputMaybe<Scalars['DateTime']>;
	node_id: Scalars['ID'];
	permission?: InputMaybe<SharePermission>;
	share_target_id: Scalars['ID'];
};

export type Node = {
	collaboration_links: Array<Maybe<CollaborationLink>>;
	created_at: Scalars['DateTime'];
	creator: User;
	description: Scalars['String'];
	flagged: Scalars['Boolean'];
	id: Scalars['ID'];
	last_editor?: Maybe<User>;
	links: Array<Maybe<Link>>;
	name: Scalars['String'];
	owner?: Maybe<User>;
	parent?: Maybe<File | Folder>;
	permissions: Permissions;
	rootId?: Maybe<Scalars['ID']>;
	share?: Maybe<Share>;
	shares: Array<Maybe<Share>>;
	type: NodeType;
	updated_at: Scalars['DateTime'];
};

export type NodeShareArgs = {
	share_target_id: Scalars['ID'];
};

export type NodeSharesArgs = {
	cursor?: InputMaybe<Scalars['String']>;
	limit: Scalars['Int'];
	sorts?: InputMaybe<Array<ShareSort>>;
};

export type NodePage = {
	__typename?: 'NodePage';
	nodes: Array<Maybe<File | Folder>>;
	page_token?: Maybe<Scalars['String']>;
};

export enum NodeSort {
	LastEditorAsc = 'LAST_EDITOR_ASC',
	LastEditorDesc = 'LAST_EDITOR_DESC',
	NameAsc = 'NAME_ASC',
	NameDesc = 'NAME_DESC',
	OwnerAsc = 'OWNER_ASC',
	OwnerDesc = 'OWNER_DESC',
	SizeAsc = 'SIZE_ASC',
	SizeDesc = 'SIZE_DESC',
	TypeAsc = 'TYPE_ASC',
	TypeDesc = 'TYPE_DESC',
	UpdatedAtAsc = 'UPDATED_AT_ASC',
	UpdatedAtDesc = 'UPDATED_AT_DESC'
}

export enum NodeType {
	Application = 'APPLICATION',
	Audio = 'AUDIO',
	Folder = 'FOLDER',
	Image = 'IMAGE',
	Message = 'MESSAGE',
	Other = 'OTHER',
	Presentation = 'PRESENTATION',
	Root = 'ROOT',
	Spreadsheet = 'SPREADSHEET',
	Text = 'TEXT',
	Video = 'VIDEO'
}

export type Permissions = {
	__typename?: 'Permissions';
	can_add_version: Scalars['Boolean'];
	can_change_link: Scalars['Boolean'];
	can_change_share: Scalars['Boolean'];
	can_delete: Scalars['Boolean'];
	can_read: Scalars['Boolean'];
	can_read_link: Scalars['Boolean'];
	can_read_share: Scalars['Boolean'];
	can_share: Scalars['Boolean'];
	can_write_file: Scalars['Boolean'];
	can_write_folder: Scalars['Boolean'];
};

export type Query = {
	__typename?: 'Query';
	findNodes?: Maybe<NodePage>;
	getAccountByEmail?: Maybe<Account>;
	getAccountsByEmail: Array<Maybe<Account>>;
	getCollaborationLinks: Array<Maybe<CollaborationLink>>;
	getConfigs: Array<Maybe<Config>>;
	getLinks: Array<Maybe<Link>>;
	getNode?: Maybe<File | Folder>;
	getPath: Array<Maybe<File | Folder>>;
	getRootsList: Array<Maybe<Root>>;
	getShare?: Maybe<Share>;
	getUserById?: Maybe<User>;
	getVersions: Array<Maybe<File>>;
};

export type QueryFindNodesArgs = {
	cascade?: InputMaybe<Scalars['Boolean']>;
	direct_share?: InputMaybe<Scalars['Boolean']>;
	flagged?: InputMaybe<Scalars['Boolean']>;
	folder_id?: InputMaybe<Scalars['String']>;
	keywords?: InputMaybe<Array<Scalars['String']>>;
	limit?: InputMaybe<Scalars['Int']>;
	owner_id?: InputMaybe<Scalars['String']>;
	page_token?: InputMaybe<Scalars['String']>;
	shared_by_me?: InputMaybe<Scalars['Boolean']>;
	shared_with_me?: InputMaybe<Scalars['Boolean']>;
	sort?: InputMaybe<NodeSort>;
	type?: InputMaybe<NodeType>;
};

export type QueryGetAccountByEmailArgs = {
	email: Scalars['String'];
};

export type QueryGetAccountsByEmailArgs = {
	emails: Array<Scalars['String']>;
};

export type QueryGetCollaborationLinksArgs = {
	node_id: Scalars['ID'];
};

export type QueryGetLinksArgs = {
	node_id: Scalars['ID'];
};

export type QueryGetNodeArgs = {
	node_id: Scalars['ID'];
	version?: InputMaybe<Scalars['Int']>;
};

export type QueryGetPathArgs = {
	node_id: Scalars['ID'];
};

export type QueryGetShareArgs = {
	node_id: Scalars['ID'];
	share_target_id: Scalars['ID'];
};

export type QueryGetUserByIdArgs = {
	user_id: Scalars['ID'];
};

export type QueryGetVersionsArgs = {
	node_id: Scalars['ID'];
	versions?: InputMaybe<Array<Scalars['Int']>>;
};

export type Root = {
	__typename?: 'Root';
	id: Scalars['ID'];
	name: Scalars['String'];
};

export type Share = {
	__typename?: 'Share';
	created_at: Scalars['DateTime'];
	expires_at?: Maybe<Scalars['DateTime']>;
	node: File | Folder;
	permission: SharePermission;
	share_target?: Maybe<SharedTarget>;
};

export enum SharePermission {
	ReadAndShare = 'READ_AND_SHARE',
	ReadAndWrite = 'READ_AND_WRITE',
	ReadOnly = 'READ_ONLY',
	ReadWriteAndShare = 'READ_WRITE_AND_SHARE'
}

export enum ShareSort {
	CreationAsc = 'CREATION_ASC',
	CreationDesc = 'CREATION_DESC',
	ExpirationAsc = 'EXPIRATION_ASC',
	ExpirationDesc = 'EXPIRATION_DESC',
	SharePermissionsAsc = 'SHARE_PERMISSIONS_ASC',
	SharePermissionsDesc = 'SHARE_PERMISSIONS_DESC',
	TargetUserAsc = 'TARGET_USER_ASC',
	TargetUserDesc = 'TARGET_USER_DESC'
}

export type SharedTarget = DistributionList | User;

export type User = {
	__typename?: 'User';
	email: Scalars['String'];
	full_name: Scalars['String'];
	id: Scalars['ID'];
};

export type ResolverTypeWrapper<T> = Promise<T> | T;

export type ResolverWithResolve<TResult, TParent, TContext, TArgs> = {
	resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};
export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> =
	| ResolverFn<TResult, TParent, TContext, TArgs>
	| ResolverWithResolve<TResult, TParent, TContext, TArgs>;

export type ResolverFn<TResult, TParent, TContext, TArgs> = (
	parent: TParent,
	args: TArgs,
	context: TContext,
	info: GraphQLResolveInfo
) => Promise<TResult> | TResult;

export type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (
	parent: TParent,
	args: TArgs,
	context: TContext,
	info: GraphQLResolveInfo
) => AsyncIterable<TResult> | Promise<AsyncIterable<TResult>>;

export type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (
	parent: TParent,
	args: TArgs,
	context: TContext,
	info: GraphQLResolveInfo
) => TResult | Promise<TResult>;

export interface SubscriptionSubscriberObject<
	TResult,
	TKey extends string,
	TParent,
	TContext,
	TArgs
> {
	subscribe: SubscriptionSubscribeFn<{ [key in TKey]: TResult }, TParent, TContext, TArgs>;
	resolve?: SubscriptionResolveFn<TResult, { [key in TKey]: TResult }, TContext, TArgs>;
}

export interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {
	subscribe: SubscriptionSubscribeFn<any, TParent, TContext, TArgs>;
	resolve: SubscriptionResolveFn<TResult, any, TContext, TArgs>;
}

export type SubscriptionObject<TResult, TKey extends string, TParent, TContext, TArgs> =
	| SubscriptionSubscriberObject<TResult, TKey, TParent, TContext, TArgs>
	| SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;

export type SubscriptionResolver<
	TResult,
	TKey extends string,
	TParent = {},
	TContext = {},
	TArgs = {}
> =
	| ((...args: any[]) => SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>)
	| SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>;

export type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (
	parent: TParent,
	context: TContext,
	info: GraphQLResolveInfo
) => Maybe<TTypes> | Promise<Maybe<TTypes>>;

export type IsTypeOfResolverFn<T = {}, TContext = {}> = (
	obj: T,
	context: TContext,
	info: GraphQLResolveInfo
) => boolean | Promise<boolean>;

export type NextResolverFn<T> = () => Promise<T>;

export type DirectiveResolverFn<TResult = {}, TParent = {}, TContext = {}, TArgs = {}> = (
	next: NextResolverFn<TResult>,
	parent: TParent,
	args: TArgs,
	context: TContext,
	info: GraphQLResolveInfo
) => TResult | Promise<TResult>;

/** Mapping of union types */
export type ResolversUnionTypes = {
	Account: DistributionList | User;
	SharedTarget: DistributionList | User;
};

/** Mapping of union parent types */
export type ResolversUnionParentTypes = {
	Account: DistributionList | User;
	SharedTarget: DistributionList | User;
};

/** Mapping between all available schema types and the resolvers types */
export type ResolversTypes = {
	Account: ResolverTypeWrapper<ResolversUnionTypes['Account']>;
	Boolean: ResolverTypeWrapper<Scalars['Boolean']>;
	CollaborationLink: ResolverTypeWrapper<CollaborationLink>;
	Config: ResolverTypeWrapper<Config>;
	DateTime: ResolverTypeWrapper<Scalars['DateTime']>;
	DistributionList: ResolverTypeWrapper<DistributionList>;
	File: ResolverTypeWrapper<File>;
	Float: ResolverTypeWrapper<Scalars['Float']>;
	Folder: ResolverTypeWrapper<Folder>;
	ID: ResolverTypeWrapper<Scalars['ID']>;
	Int: ResolverTypeWrapper<Scalars['Int']>;
	Link: ResolverTypeWrapper<Link>;
	Mutation: ResolverTypeWrapper<{}>;
	Node: ResolversTypes['File'] | ResolversTypes['Folder'];
	NodePage: ResolverTypeWrapper<NodePage>;
	NodeSort: NodeSort;
	NodeType: NodeType;
	Permissions: ResolverTypeWrapper<Permissions>;
	Query: ResolverTypeWrapper<{}>;
	Root: ResolverTypeWrapper<Root>;
	Share: ResolverTypeWrapper<
		Omit<Share, 'share_target'> & { share_target?: Maybe<ResolversTypes['SharedTarget']> }
	>;
	SharePermission: SharePermission;
	ShareSort: ShareSort;
	SharedTarget: ResolverTypeWrapper<ResolversUnionTypes['SharedTarget']>;
	String: ResolverTypeWrapper<Scalars['String']>;
	User: ResolverTypeWrapper<User>;
};

/** Mapping between all available schema types and the resolvers parents */
export type ResolversParentTypes = {
	Account: ResolversUnionParentTypes['Account'];
	Boolean: Scalars['Boolean'];
	CollaborationLink: CollaborationLink;
	Config: Config;
	DateTime: Scalars['DateTime'];
	DistributionList: DistributionList;
	File: File;
	Float: Scalars['Float'];
	Folder: Folder;
	ID: Scalars['ID'];
	Int: Scalars['Int'];
	Link: Link;
	Mutation: {};
	Node: ResolversParentTypes['File'] | ResolversParentTypes['Folder'];
	NodePage: NodePage;
	Permissions: Permissions;
	Query: {};
	Root: Root;
	Share: Omit<Share, 'share_target'> & {
		share_target?: Maybe<ResolversParentTypes['SharedTarget']>;
	};
	SharedTarget: ResolversUnionParentTypes['SharedTarget'];
	String: Scalars['String'];
	User: User;
};

export type AccountResolvers<
	ContextType = any,
	ParentType extends ResolversParentTypes['Account'] = ResolversParentTypes['Account']
> = {
	__resolveType: TypeResolveFn<'DistributionList' | 'User', ParentType, ContextType>;
};

export type CollaborationLinkResolvers<
	ContextType = any,
	ParentType extends ResolversParentTypes['CollaborationLink'] = ResolversParentTypes['CollaborationLink']
> = {
	created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
	id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
	node?: Resolver<ResolversTypes['Node'], ParentType, ContextType>;
	permission?: Resolver<ResolversTypes['SharePermission'], ParentType, ContextType>;
	url?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
	__isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ConfigResolvers<
	ContextType = any,
	ParentType extends ResolversParentTypes['Config'] = ResolversParentTypes['Config']
> = {
	name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
	value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
	__isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface DateTimeScalarConfig
	extends GraphQLScalarTypeConfig<ResolversTypes['DateTime'], any> {
	name: 'DateTime';
}

export type DistributionListResolvers<
	ContextType = any,
	ParentType extends ResolversParentTypes['DistributionList'] = ResolversParentTypes['DistributionList']
> = {
	id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
	name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
	users?: Resolver<
		Array<Maybe<ResolversTypes['User']>>,
		ParentType,
		ContextType,
		RequireFields<DistributionListUsersArgs, 'limit'>
	>;
	__isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FileResolvers<
	ContextType = any,
	ParentType extends ResolversParentTypes['File'] = ResolversParentTypes['File']
> = {
	cloned_from_version?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
	collaboration_links?: Resolver<
		Array<Maybe<ResolversTypes['CollaborationLink']>>,
		ParentType,
		ContextType
	>;
	created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
	creator?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
	description?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
	extension?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
	flagged?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
	id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
	keep_forever?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
	last_editor?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
	links?: Resolver<Array<Maybe<ResolversTypes['Link']>>, ParentType, ContextType>;
	mime_type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
	name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
	owner?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
	parent?: Resolver<Maybe<ResolversTypes['Node']>, ParentType, ContextType>;
	permissions?: Resolver<ResolversTypes['Permissions'], ParentType, ContextType>;
	rootId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
	share?: Resolver<
		Maybe<ResolversTypes['Share']>,
		ParentType,
		ContextType,
		RequireFields<FileShareArgs, 'share_target_id'>
	>;
	shares?: Resolver<
		Array<Maybe<ResolversTypes['Share']>>,
		ParentType,
		ContextType,
		RequireFields<FileSharesArgs, 'limit'>
	>;
	size?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
	type?: Resolver<ResolversTypes['NodeType'], ParentType, ContextType>;
	updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
	version?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
	__isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FolderResolvers<
	ContextType = any,
	ParentType extends ResolversParentTypes['Folder'] = ResolversParentTypes['Folder']
> = {
	children?: Resolver<
		ResolversTypes['NodePage'],
		ParentType,
		ContextType,
		RequireFields<FolderChildrenArgs, 'limit' | 'sort'>
	>;
	collaboration_links?: Resolver<
		Array<Maybe<ResolversTypes['CollaborationLink']>>,
		ParentType,
		ContextType
	>;
	created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
	creator?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
	description?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
	flagged?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
	id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
	last_editor?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
	links?: Resolver<Array<Maybe<ResolversTypes['Link']>>, ParentType, ContextType>;
	name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
	owner?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
	parent?: Resolver<Maybe<ResolversTypes['Node']>, ParentType, ContextType>;
	permissions?: Resolver<ResolversTypes['Permissions'], ParentType, ContextType>;
	rootId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
	share?: Resolver<
		Maybe<ResolversTypes['Share']>,
		ParentType,
		ContextType,
		RequireFields<FolderShareArgs, 'share_target_id'>
	>;
	shares?: Resolver<
		Array<Maybe<ResolversTypes['Share']>>,
		ParentType,
		ContextType,
		RequireFields<FolderSharesArgs, 'limit'>
	>;
	type?: Resolver<ResolversTypes['NodeType'], ParentType, ContextType>;
	updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
	__isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LinkResolvers<
	ContextType = any,
	ParentType extends ResolversParentTypes['Link'] = ResolversParentTypes['Link']
> = {
	created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
	description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
	expires_at?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
	id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
	node?: Resolver<ResolversTypes['Node'], ParentType, ContextType>;
	url?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
	__isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MutationResolvers<
	ContextType = any,
	ParentType extends ResolversParentTypes['Mutation'] = ResolversParentTypes['Mutation']
> = {
	cloneVersion?: Resolver<
		ResolversTypes['File'],
		ParentType,
		ContextType,
		RequireFields<MutationCloneVersionArgs, 'node_id' | 'version'>
	>;
	copyNodes?: Resolver<
		Maybe<Array<ResolversTypes['Node']>>,
		ParentType,
		ContextType,
		RequireFields<MutationCopyNodesArgs, 'destination_id'>
	>;
	createCollaborationLink?: Resolver<
		ResolversTypes['CollaborationLink'],
		ParentType,
		ContextType,
		RequireFields<MutationCreateCollaborationLinkArgs, 'node_id' | 'permission'>
	>;
	createFolder?: Resolver<
		ResolversTypes['Node'],
		ParentType,
		ContextType,
		RequireFields<MutationCreateFolderArgs, 'destination_id' | 'name'>
	>;
	createLink?: Resolver<
		ResolversTypes['Link'],
		ParentType,
		ContextType,
		RequireFields<MutationCreateLinkArgs, 'node_id'>
	>;
	createShare?: Resolver<
		ResolversTypes['Share'],
		ParentType,
		ContextType,
		RequireFields<MutationCreateShareArgs, 'node_id' | 'permission' | 'share_target_id'>
	>;
	deleteCollaborationLinks?: Resolver<
		Array<Maybe<ResolversTypes['ID']>>,
		ParentType,
		ContextType,
		RequireFields<MutationDeleteCollaborationLinksArgs, 'collaboration_link_ids'>
	>;
	deleteLinks?: Resolver<
		Array<Maybe<ResolversTypes['ID']>>,
		ParentType,
		ContextType,
		RequireFields<MutationDeleteLinksArgs, 'link_ids'>
	>;
	deleteNodes?: Resolver<
		Maybe<Array<ResolversTypes['ID']>>,
		ParentType,
		ContextType,
		Partial<MutationDeleteNodesArgs>
	>;
	deleteShare?: Resolver<
		ResolversTypes['Boolean'],
		ParentType,
		ContextType,
		RequireFields<MutationDeleteShareArgs, 'node_id' | 'share_target_id'>
	>;
	deleteVersions?: Resolver<
		Array<Maybe<ResolversTypes['Int']>>,
		ParentType,
		ContextType,
		RequireFields<MutationDeleteVersionsArgs, 'node_id'>
	>;
	flagNodes?: Resolver<
		Maybe<Array<ResolversTypes['ID']>>,
		ParentType,
		ContextType,
		RequireFields<MutationFlagNodesArgs, 'flag'>
	>;
	keepVersions?: Resolver<
		Array<Maybe<ResolversTypes['Int']>>,
		ParentType,
		ContextType,
		RequireFields<MutationKeepVersionsArgs, 'keep_forever' | 'node_id' | 'versions'>
	>;
	moveNodes?: Resolver<
		Maybe<Array<ResolversTypes['Node']>>,
		ParentType,
		ContextType,
		RequireFields<MutationMoveNodesArgs, 'destination_id'>
	>;
	restoreNodes?: Resolver<
		Maybe<Array<Maybe<ResolversTypes['Node']>>>,
		ParentType,
		ContextType,
		Partial<MutationRestoreNodesArgs>
	>;
	trashNodes?: Resolver<
		Maybe<Array<ResolversTypes['ID']>>,
		ParentType,
		ContextType,
		Partial<MutationTrashNodesArgs>
	>;
	updateLink?: Resolver<
		Maybe<ResolversTypes['Link']>,
		ParentType,
		ContextType,
		RequireFields<MutationUpdateLinkArgs, 'link_id'>
	>;
	updateNode?: Resolver<
		ResolversTypes['Node'],
		ParentType,
		ContextType,
		RequireFields<MutationUpdateNodeArgs, 'node_id'>
	>;
	updateShare?: Resolver<
		Maybe<ResolversTypes['Share']>,
		ParentType,
		ContextType,
		RequireFields<MutationUpdateShareArgs, 'node_id' | 'share_target_id'>
	>;
};

export type NodeResolvers<
	ContextType = any,
	ParentType extends ResolversParentTypes['Node'] = ResolversParentTypes['Node']
> = {
	__resolveType: TypeResolveFn<'File' | 'Folder', ParentType, ContextType>;
	collaboration_links?: Resolver<
		Array<Maybe<ResolversTypes['CollaborationLink']>>,
		ParentType,
		ContextType
	>;
	created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
	creator?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
	description?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
	flagged?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
	id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
	last_editor?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
	links?: Resolver<Array<Maybe<ResolversTypes['Link']>>, ParentType, ContextType>;
	name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
	owner?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
	parent?: Resolver<Maybe<ResolversTypes['Node']>, ParentType, ContextType>;
	permissions?: Resolver<ResolversTypes['Permissions'], ParentType, ContextType>;
	rootId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
	share?: Resolver<
		Maybe<ResolversTypes['Share']>,
		ParentType,
		ContextType,
		RequireFields<NodeShareArgs, 'share_target_id'>
	>;
	shares?: Resolver<
		Array<Maybe<ResolversTypes['Share']>>,
		ParentType,
		ContextType,
		RequireFields<NodeSharesArgs, 'limit'>
	>;
	type?: Resolver<ResolversTypes['NodeType'], ParentType, ContextType>;
	updated_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
};

export type NodePageResolvers<
	ContextType = any,
	ParentType extends ResolversParentTypes['NodePage'] = ResolversParentTypes['NodePage']
> = {
	nodes?: Resolver<Array<Maybe<ResolversTypes['Node']>>, ParentType, ContextType>;
	page_token?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
	__isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PermissionsResolvers<
	ContextType = any,
	ParentType extends ResolversParentTypes['Permissions'] = ResolversParentTypes['Permissions']
> = {
	can_add_version?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
	can_change_link?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
	can_change_share?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
	can_delete?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
	can_read?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
	can_read_link?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
	can_read_share?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
	can_share?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
	can_write_file?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
	can_write_folder?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
	__isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type QueryResolvers<
	ContextType = any,
	ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']
> = {
	findNodes?: Resolver<
		Maybe<ResolversTypes['NodePage']>,
		ParentType,
		ContextType,
		Partial<QueryFindNodesArgs>
	>;
	getAccountByEmail?: Resolver<
		Maybe<ResolversTypes['Account']>,
		ParentType,
		ContextType,
		RequireFields<QueryGetAccountByEmailArgs, 'email'>
	>;
	getAccountsByEmail?: Resolver<
		Array<Maybe<ResolversTypes['Account']>>,
		ParentType,
		ContextType,
		RequireFields<QueryGetAccountsByEmailArgs, 'emails'>
	>;
	getCollaborationLinks?: Resolver<
		Array<Maybe<ResolversTypes['CollaborationLink']>>,
		ParentType,
		ContextType,
		RequireFields<QueryGetCollaborationLinksArgs, 'node_id'>
	>;
	getConfigs?: Resolver<Array<Maybe<ResolversTypes['Config']>>, ParentType, ContextType>;
	getLinks?: Resolver<
		Array<Maybe<ResolversTypes['Link']>>,
		ParentType,
		ContextType,
		RequireFields<QueryGetLinksArgs, 'node_id'>
	>;
	getNode?: Resolver<
		Maybe<ResolversTypes['Node']>,
		ParentType,
		ContextType,
		RequireFields<QueryGetNodeArgs, 'node_id'>
	>;
	getPath?: Resolver<
		Array<Maybe<ResolversTypes['Node']>>,
		ParentType,
		ContextType,
		RequireFields<QueryGetPathArgs, 'node_id'>
	>;
	getRootsList?: Resolver<Array<Maybe<ResolversTypes['Root']>>, ParentType, ContextType>;
	getShare?: Resolver<
		Maybe<ResolversTypes['Share']>,
		ParentType,
		ContextType,
		RequireFields<QueryGetShareArgs, 'node_id' | 'share_target_id'>
	>;
	getUserById?: Resolver<
		Maybe<ResolversTypes['User']>,
		ParentType,
		ContextType,
		RequireFields<QueryGetUserByIdArgs, 'user_id'>
	>;
	getVersions?: Resolver<
		Array<Maybe<ResolversTypes['File']>>,
		ParentType,
		ContextType,
		RequireFields<QueryGetVersionsArgs, 'node_id'>
	>;
};

export type RootResolvers<
	ContextType = any,
	ParentType extends ResolversParentTypes['Root'] = ResolversParentTypes['Root']
> = {
	id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
	name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
	__isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ShareResolvers<
	ContextType = any,
	ParentType extends ResolversParentTypes['Share'] = ResolversParentTypes['Share']
> = {
	created_at?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
	expires_at?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
	node?: Resolver<ResolversTypes['Node'], ParentType, ContextType>;
	permission?: Resolver<ResolversTypes['SharePermission'], ParentType, ContextType>;
	share_target?: Resolver<Maybe<ResolversTypes['SharedTarget']>, ParentType, ContextType>;
	__isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SharedTargetResolvers<
	ContextType = any,
	ParentType extends ResolversParentTypes['SharedTarget'] = ResolversParentTypes['SharedTarget']
> = {
	__resolveType: TypeResolveFn<'DistributionList' | 'User', ParentType, ContextType>;
};

export type UserResolvers<
	ContextType = any,
	ParentType extends ResolversParentTypes['User'] = ResolversParentTypes['User']
> = {
	email?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
	full_name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
	id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
	__isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type Resolvers<ContextType = any> = {
	Account?: AccountResolvers<ContextType>;
	CollaborationLink?: CollaborationLinkResolvers<ContextType>;
	Config?: ConfigResolvers<ContextType>;
	DateTime?: GraphQLScalarType;
	DistributionList?: DistributionListResolvers<ContextType>;
	File?: FileResolvers<ContextType>;
	Folder?: FolderResolvers<ContextType>;
	Link?: LinkResolvers<ContextType>;
	Mutation?: MutationResolvers<ContextType>;
	Node?: NodeResolvers<ContextType>;
	NodePage?: NodePageResolvers<ContextType>;
	Permissions?: PermissionsResolvers<ContextType>;
	Query?: QueryResolvers<ContextType>;
	Root?: RootResolvers<ContextType>;
	Share?: ShareResolvers<ContextType>;
	SharedTarget?: SharedTargetResolvers<ContextType>;
	User?: UserResolvers<ContextType>;
};
